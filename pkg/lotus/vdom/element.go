// Package vdom provides a Virtual DOM implementation for terminal UIs.
//
// This package is standalone and has no dependencies on layout, rendering, or styling.
// It represents the declarative UI tree structure similar to React's Virtual DOM.
//
// The Element tree is immutable after creation - it describes WHAT to render,
// not HOW or WHERE.
package vdom

// Overflow controls how content that exceeds a box's boundaries is handled
type Overflow string

const (
	// OverflowAuto enables scrolling when content exceeds viewport (smart default for flexGrow)
	OverflowAuto Overflow = "auto"
	// OverflowHidden clips content that exceeds boundaries without scrolling
	OverflowHidden Overflow = "hidden"
)

// Element represents a virtual DOM node (like React.createElement())
// This is a pure data structure with no side effects.
type Element struct {
	// Type identifies the element kind
	Type ElementType

	// Path is the tree position (auto-generated by reconciler, e.g., "0.1.2")
	// Used for stable component identity and internal tracking
	Path string

	// Tag name for box elements ("box", "text", etc.)
	Tag string

	// Props are attributes/properties for this element
	Props Props

	// Children are nested elements
	Children []*Element

	// Component reference (if Type == ComponentElement)
	Component Component

	// Text content (if Type == TextElement)
	Text string
}

// ElementType identifies what kind of element this is
type ElementType int

const (
	// BoxElement is a container element (like <div>)
	BoxElement ElementType = iota

	// TextElement contains text content (like text node)
	TextElement

	// ComponentElement wraps a reusable component
	ComponentElement
)

// Props holds element properties (attributes + inline styles)
type Props struct {
	// Attributes are semantic properties (id, class, etc.)
	Attributes map[string]string

	// Styles are inline CSS-like properties
	Styles map[string]string

	// Classes for CSS selectors
	Classes []string
}

// Component is anything that can render itself to an Element
type Component interface {
	// Render returns the element tree for this component
	Render() *Element
}

// Node represents anything that can be part of the virtual DOM tree
// Both elements and components satisfy this interface
type Node interface {
	IsNode()
}

// IsNode marks Element as a Node
func (e *Element) IsNode() {}

// ToElement converts a Node to an Element
// For components, it preserves the component reference in Element.Component
// so that event handlers can find focusable components
func ToElement(n Node) *Element {
	switch v := n.(type) {
	case *Element:
		return v
	case Component:
		// Render the component to get its element tree
		rendered := v.Render()
		// Preserve the component reference (React-like)
		if rendered != nil {
			rendered.Component = v
			rendered.Type = ComponentElement
		}
		return rendered
	default:
		return nil
	}
}

// NewElement creates a new box element
func NewElement(tag string, props Props, children ...*Element) *Element {
	if props.Attributes == nil {
		props.Attributes = make(map[string]string)
	}
	if props.Styles == nil {
		props.Styles = make(map[string]string)
	}

	return &Element{
		Type:     BoxElement,
		Tag:      tag,
		Props:    props,
		Children: children,
	}
}

// NewText creates a text element
func NewText(text string) *Element {
	return &Element{
		Type: TextElement,
		Text: text,
	}
}

// WithTag sets the element tag (for chaining)
func (e *Element) WithProp(key, value string) *Element {
	if e.Props.Attributes == nil {
		e.Props.Attributes = make(map[string]string)
	}
	e.Props.Attributes[key] = value
	return e
}

// WithStyle sets an inline style (for chaining)
func (e *Element) WithStyle(key, value string) *Element {
	if e.Props.Styles == nil {
		e.Props.Styles = make(map[string]string)
	}
	e.Props.Styles[key] = value
	return e
}

// Typed style methods for type safety and better autocomplete

// BorderStyle represents the visual style of borders
type BorderStyle string

const (
	BorderStyleSingle  BorderStyle = "single"  // ┌─┐ Default box drawing
	BorderStyleRounded BorderStyle = "rounded" // ╭─╮ Smooth corners
	BorderStyleDouble  BorderStyle = "double"  // ╔═╗ Double lines
	BorderStyleNone    BorderStyle = "none"    // No border
)

// AlignSelf represents cross-axis alignment for flex items
type AlignSelf string

const (
	AlignSelfStretch   AlignSelf = "stretch"    // Fill cross-axis (default)
	AlignSelfFlexStart AlignSelf = "flex-start" // Align to start
	AlignSelfFlexEnd   AlignSelf = "flex-end"   // Align to end
	AlignSelfCenter    AlignSelf = "center"     // Center on cross-axis
)

// AlignItems represents cross-axis alignment for flex container children
type AlignItems string

const (
	AlignItemsStretch   AlignItems = "stretch"    // Stretch children (default)
	AlignItemsFlexStart AlignItems = "flex-start" // Align to start
	AlignItemsFlexEnd   AlignItems = "flex-end"   // Align to end
	AlignItemsCenter    AlignItems = "center"     // Center children
)

// TextAlign represents horizontal text alignment
type TextAlign string

const (
	TextAlignLeft   TextAlign = "left"   // Left-aligned (default)
	TextAlignCenter TextAlign = "center" // Centered
	TextAlignRight  TextAlign = "right"  // Right-aligned
)

// JustifyContent represents main-axis alignment in flexbox
type JustifyContent string

const (
	JustifyContentFlexStart    JustifyContent = "flex-start"    // Align to start (default)
	JustifyContentFlexEnd      JustifyContent = "flex-end"      // Align to end
	JustifyContentCenter       JustifyContent = "center"        // Center items
	JustifyContentSpaceBetween JustifyContent = "space-between" // Space between items
)

// WithBorderStyle sets the border style with type safety
func (e *Element) WithBorderStyle(style BorderStyle) *Element {
	return e.WithStyle("border-style", string(style))
}

// WithFlexGrow sets flex-grow for flexible sizing
func (e *Element) WithFlexGrow(grow int) *Element {
	if grow < 0 {
		grow = 0
	}
	return e.WithStyle("flex-grow", intToString(grow))
}

// WithFlexShrink sets flex-shrink
func (e *Element) WithFlexShrink(shrink int) *Element {
	if shrink < 0 {
		shrink = 0
	}
	return e.WithStyle("flex-shrink", intToString(shrink))
}

// WithAlignSelf sets cross-axis alignment for this item
func (e *Element) WithAlignSelf(align AlignSelf) *Element {
	return e.WithStyle("align-self", string(align))
}

// WithAlignItems sets cross-axis alignment for children of this flex container
func (e *Element) WithAlignItems(align AlignItems) *Element {
	return e.WithStyle("align-items", string(align))
}

// WithJustifyContent sets main-axis alignment for flex containers
func (e *Element) WithJustifyContent(justify JustifyContent) *Element {
	return e.WithStyle("justify-content", string(justify))
}

// WithOverflow sets overflow behavior (scrolling vs clipping)
func (e *Element) WithOverflow(overflow Overflow) *Element {
	return e.WithStyle("overflow", string(overflow))
}

// WithColor sets text color
func (e *Element) WithColor(color string) *Element {
	return e.WithStyle("color", color)
}

// WithBgColor sets background color
func (e *Element) WithBgColor(color string) *Element {
	return e.WithStyle("background-color", color)
}

// WithWidth sets width (number of cells)
func (e *Element) WithWidth(width int) *Element {
	return e.WithStyle("width", intToString(width))
}

// WithHeight sets height (number of lines)
func (e *Element) WithHeight(height int) *Element {
	return e.WithStyle("height", intToString(height))
}

// WithPadding sets padding on all sides
func (e *Element) WithPadding(padding int) *Element {
	return e.WithStyle("padding", intToString(padding))
}

// WithPaddingX sets horizontal padding (left and right)
func (e *Element) WithPaddingX(padding int) *Element {
	p := intToString(padding)
	e.WithStyle("padding-left", p)
	e.WithStyle("padding-right", p)
	return e
}

// WithPaddingY sets vertical padding (top and bottom)
func (e *Element) WithPaddingY(padding int) *Element {
	p := intToString(padding)
	e.WithStyle("padding-top", p)
	e.WithStyle("padding-bottom", p)
	return e
}

// WithMargin sets margin on all sides
func (e *Element) WithMargin(margin int) *Element {
	return e.WithStyle("margin", intToString(margin))
}

// WithMarginX sets horizontal margins (left and right)
func (e *Element) WithMarginX(margin int) *Element {
	m := intToString(margin)
	e.WithStyle("margin-left", m)
	e.WithStyle("margin-right", m)
	return e
}

// WithMarginY sets vertical margins (top and bottom)
func (e *Element) WithMarginY(margin int) *Element {
	m := intToString(margin)
	e.WithStyle("margin-top", m)
	e.WithStyle("margin-bottom", m)
	return e
}

// WithGap sets the gap between flex children (CSS gap property)
func (e *Element) WithGap(gap int) *Element {
	return e.WithStyle("gap", intToString(gap))
}

// WithMinWidth sets minimum width
func (e *Element) WithMinWidth(width int) *Element {
	return e.WithStyle("min-width", intToString(width))
}

// WithMaxWidth sets maximum width
func (e *Element) WithMaxWidth(width int) *Element {
	return e.WithStyle("max-width", intToString(width))
}

// WithMinHeight sets minimum height
func (e *Element) WithMinHeight(height int) *Element {
	return e.WithStyle("min-height", intToString(height))
}

// WithMaxHeight sets maximum height
func (e *Element) WithMaxHeight(height int) *Element {
	return e.WithStyle("max-height", intToString(height))
}

// WithScroll enables scrolling on this container with auto-follow behavior
// Deprecated: Use WithOverflow(OverflowAuto) instead
// When enabled, content that exceeds the viewport will be scrollable.
// Auto-follows tail by default (pauses when user scrolls up manually).
func (e *Element) WithScroll(enabled bool) *Element {
	if enabled {
		e.WithStyle("overflow-y", "auto")
		e.WithStyle("scroll-behavior", "auto-follow")
	} else {
		e.WithStyle("overflow-y", "visible")
		e.WithStyle("scroll-behavior", "none")
	}
	return e
}

// WithPosition sets positioning mode (static, relative, absolute)
func (e *Element) WithPosition(position string) *Element {
	return e.WithStyle("position", position)
}

// WithZIndex sets stacking order
func (e *Element) WithZIndex(zIndex int) *Element {
	return e.WithStyle("z-index", intToString(zIndex))
}

// WithPointerEvents controls whether element receives input events
func (e *Element) WithPointerEvents(enabled bool) *Element {
	if enabled {
		return e.WithStyle("pointer-events", "auto")
	}
	return e.WithStyle("pointer-events", "none")
}

// WithTextAlign sets text alignment
func (e *Element) WithTextAlign(align TextAlign) *Element {
	return e.WithStyle("text-align", string(align))
}

// WithFontWeight sets font weight (normal, bold)
func (e *Element) WithFontWeight(weight string) *Element {
	return e.WithStyle("font-weight", weight)
}

// WithBold is a convenience method for bold text
func (e *Element) WithBold() *Element {
	return e.WithStyle("font-weight", "bold")
}

// WithFontStyle sets font style (normal, italic)
func (e *Element) WithFontStyle(style string) *Element {
	return e.WithStyle("font-style", style)
}

// WithItalic is a convenience method for italic text
func (e *Element) WithItalic() *Element {
	return e.WithStyle("font-style", "italic")
}

// WithTextDecoration sets text decoration (none, underline, strikethrough)
func (e *Element) WithTextDecoration(decoration string) *Element {
	return e.WithStyle("text-decoration", decoration)
}

// WithUnderline is a convenience method for underlined text
func (e *Element) WithUnderline() *Element {
	return e.WithStyle("text-decoration", "underline")
}

// WithStrikethrough is a convenience method for strikethrough text
func (e *Element) WithStrikethrough() *Element {
	return e.WithStyle("text-decoration", "strikethrough")
}

// WithOpacity sets opacity (0-100, 0=invisible, 50=dim, 100=normal)
func (e *Element) WithOpacity(opacity int) *Element {
	return e.WithStyle("opacity", intToString(opacity))
}

// WithDim is a convenience method for dimmed text (50% opacity)
func (e *Element) WithDim() *Element {
	return e.WithStyle("opacity", "50")
}

// WithTextOverflow sets text overflow behavior (clip, ellipsis)
func (e *Element) WithTextOverflow(overflow string) *Element {
	return e.WithStyle("text-overflow", overflow)
}

// WithWhiteSpace sets whitespace handling (normal, nowrap, pre)
func (e *Element) WithWhiteSpace(whitespace string) *Element {
	return e.WithStyle("white-space", whitespace)
}

// WithWordWrap sets word wrapping (true/false)
func (e *Element) WithWordWrap(wrap bool) *Element {
	if wrap {
		return e.WithStyle("word-wrap", "true")
	}
	return e.WithStyle("word-wrap", "none")
}

// WithBorderColor sets border color
func (e *Element) WithBorderColor(color string) *Element {
	return e.WithStyle("border-color", color)
}

// WithReverse inverts foreground and background colors (for selections)
func (e *Element) WithReverse() *Element {
	return e.WithStyle("reverse", "true")
}

// WithMaxLines sets the maximum number of lines for text content (0 = unlimited)
func (e *Element) WithMaxLines(max int) *Element {
	return e.WithStyle("max-lines", intToString(max))
}

// intToString converts int to string
func intToString(n int) string {
	// Fast path for common values
	switch n {
	case 0:
		return "0"
	case 1:
		return "1"
	case 2:
		return "2"
	case 3:
		return "3"
	case 4:
		return "4"
	default:
		// For larger values, build string manually
		if n < 0 {
			return "-" + intToString(-n)
		}
		if n < 10 {
			return string(rune('0' + n))
		}
		// Multi-digit: recursively build
		return intToString(n/10) + string(rune('0'+n%10))
	}
}

// Clone creates a shallow copy of the element
func (e *Element) Clone() *Element {
	clone := &Element{
		Type:      e.Type,
		Path:      e.Path,
		Tag:       e.Tag,
		Component: e.Component,
		Text:      e.Text,
	}

	// Clone props
	clone.Props.Attributes = make(map[string]string, len(e.Props.Attributes))
	for k, v := range e.Props.Attributes {
		clone.Props.Attributes[k] = v
	}
	clone.Props.Styles = make(map[string]string, len(e.Props.Styles))
	for k, v := range e.Props.Styles {
		clone.Props.Styles[k] = v
	}
	clone.Props.Classes = append([]string{}, e.Props.Classes...)

	// Clone children (shallow - children themselves are not cloned)
	clone.Children = append([]*Element{}, e.Children...)

	return clone
}

// Walk traverses the element tree depth-first
func (e *Element) Walk(fn func(*Element) bool) {
	if !fn(e) {
		return
	}
	for _, child := range e.Children {
		child.Walk(fn)
	}
}
